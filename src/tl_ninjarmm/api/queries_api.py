# coding: utf-8

"""
    NinjaOne Public API 2.0

    Ninja One Public API documentation. <br><br> See also: <br>  <a href=\"https://resources.ninjarmm.com/API/Ninja+RMM+Public+API+v2.0.5+Device+Filter+Syntax.pdf\">Device Filter syntax</a><br> <a href=\"https://resources.ninjarmm.com/API/Ninja+RMM+Public+API+v2.0.5+Webhooks.pdf\">Webhooks</a>

    The version of the OpenAPI document: 2.0.9-draft
    Contact: api@ninjarmm.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from tl_ninjarmm.models.get_antivirus_status_report_default_response import GetAntivirusStatusReportDefaultResponse
from tl_ninjarmm.models.get_antivirus_threats_default_response import GetAntivirusThreatsDefaultResponse
from tl_ninjarmm.models.get_computer_systems_default_response import GetComputerSystemsDefaultResponse
from tl_ninjarmm.models.get_custom_fields_detailed_report_default_response import GetCustomFieldsDetailedReportDefaultResponse
from tl_ninjarmm.models.get_custom_fields_report_default_response import GetCustomFieldsReportDefaultResponse
from tl_ninjarmm.models.get_device_health_report_default_response import GetDeviceHealthReportDefaultResponse
from tl_ninjarmm.models.get_device_usage200_response import GetDeviceUsage200Response
from tl_ninjarmm.models.get_disk_drives_default_response import GetDiskDrivesDefaultResponse
from tl_ninjarmm.models.get_installed_os_patches_default_response import GetInstalledOSPatchesDefaultResponse
from tl_ninjarmm.models.get_installed_software_patches_default_response import GetInstalledSoftwarePatchesDefaultResponse
from tl_ninjarmm.models.get_last_logged_on_users_report_default_response import GetLastLoggedOnUsersReportDefaultResponse
from tl_ninjarmm.models.get_network_interfaces_default_response import GetNetworkInterfacesDefaultResponse
from tl_ninjarmm.models.get_operating_systems_default_response import GetOperatingSystemsDefaultResponse
from tl_ninjarmm.models.get_policy_overrides1_default_response import GetPolicyOverrides1DefaultResponse
from tl_ninjarmm.models.get_processors_default_response import GetProcessorsDefaultResponse
from tl_ninjarmm.models.get_raid_controller_report_default_response import GetRAIDControllerReportDefaultResponse
from tl_ninjarmm.models.get_raid_drive_report_default_response import GetRAIDDriveReportDefaultResponse
from tl_ninjarmm.models.get_scoped_custom_fields_detailed_report_default_response import GetScopedCustomFieldsDetailedReportDefaultResponse
from tl_ninjarmm.models.get_scoped_custom_fields_report_default_response import GetScopedCustomFieldsReportDefaultResponse
from tl_ninjarmm.models.get_software_default_response import GetSoftwareDefaultResponse
from tl_ninjarmm.models.get_volumes_default_response import GetVolumesDefaultResponse
from tl_ninjarmm.models.get_windows_services_report_default_response import GetWindowsServicesReportDefaultResponse

from tl_ninjarmm.api_client import ApiClient, RequestSerialized
from tl_ninjarmm.api_response import ApiResponse
from tl_ninjarmm.rest import RESTResponseType


class QueriesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_antivirus_status_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        product_state: Annotated[Optional[StrictStr], Field(description="Product State filter")] = None,
        product_name: Annotated[Optional[StrictStr], Field(description="Product Name filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAntivirusStatusReportDefaultResponse:
        """Antivirus status report

        Returns list of statues of antivirus software installed on devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param product_state: Product State filter
        :type product_state: str
        :param product_name: Product Name filter
        :type product_name: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_antivirus_status_report_serialize(
            df=df,
            ts=ts,
            product_state=product_state,
            product_name=product_name,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_antivirus_status_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        product_state: Annotated[Optional[StrictStr], Field(description="Product State filter")] = None,
        product_name: Annotated[Optional[StrictStr], Field(description="Product Name filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAntivirusStatusReportDefaultResponse]:
        """Antivirus status report

        Returns list of statues of antivirus software installed on devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param product_state: Product State filter
        :type product_state: str
        :param product_name: Product Name filter
        :type product_name: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_antivirus_status_report_serialize(
            df=df,
            ts=ts,
            product_state=product_state,
            product_name=product_name,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_antivirus_status_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        product_state: Annotated[Optional[StrictStr], Field(description="Product State filter")] = None,
        product_name: Annotated[Optional[StrictStr], Field(description="Product Name filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Antivirus status report

        Returns list of statues of antivirus software installed on devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param product_state: Product State filter
        :type product_state: str
        :param product_name: Product Name filter
        :type product_name: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_antivirus_status_report_serialize(
            df=df,
            ts=ts,
            product_state=product_state,
            product_name=product_name,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_antivirus_status_report_serialize(
        self,
        df,
        ts,
        product_state,
        product_name,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if product_state is not None:
            
            _query_params.append(('productState', product_state))
            
        if product_name is not None:
            
            _query_params.append(('productName', product_name))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/antivirus-status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_antivirus_threats(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetAntivirusThreatsDefaultResponse:
        """Antivirus threats report

        Returns list of antivirus threats

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_antivirus_threats_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_antivirus_threats_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetAntivirusThreatsDefaultResponse]:
        """Antivirus threats report

        Returns list of antivirus threats

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_antivirus_threats_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_antivirus_threats_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Antivirus threats report

        Returns list of antivirus threats

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_antivirus_threats_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_antivirus_threats_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/antivirus-threats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_computer_systems(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetComputerSystemsDefaultResponse:
        """Computer systems report

        Returns computer systems information for devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_computer_systems_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_computer_systems_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetComputerSystemsDefaultResponse]:
        """Computer systems report

        Returns computer systems information for devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_computer_systems_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_computer_systems_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Computer systems report

        Returns computer systems information for devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_computer_systems_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_computer_systems_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/computer-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_custom_fields_detailed_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCustomFieldsDetailedReportDefaultResponse:
        """Custom fields detailed report

        Returns Custom Fields report with additional information about each field

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_custom_fields_detailed_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_custom_fields_detailed_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCustomFieldsDetailedReportDefaultResponse]:
        """Custom fields detailed report

        Returns Custom Fields report with additional information about each field

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_custom_fields_detailed_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_custom_fields_detailed_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Custom fields detailed report

        Returns Custom Fields report with additional information about each field

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_custom_fields_detailed_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_custom_fields_detailed_report_serialize(
        self,
        df,
        cursor,
        page_size,
        updated_after,
        fields,
        show_secure_values,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if updated_after is not None:
            
            _query_params.append(('updatedAfter', updated_after))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if show_secure_values is not None:
            
            _query_params.append(('showSecureValues', show_secure_values))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/custom-fields-detailed',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_custom_fields_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetCustomFieldsReportDefaultResponse:
        """Custom fields report

        Returns Custom Fields report

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_custom_fields_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_custom_fields_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetCustomFieldsReportDefaultResponse]:
        """Custom fields report

        Returns Custom Fields report

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_custom_fields_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_custom_fields_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Custom fields report

        Returns Custom Fields report

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_custom_fields_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_custom_fields_report_serialize(
        self,
        df,
        cursor,
        page_size,
        updated_after,
        fields,
        show_secure_values,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if updated_after is not None:
            
            _query_params.append(('updatedAfter', updated_after))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if show_secure_values is not None:
            
            _query_params.append(('showSecureValues', show_secure_values))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/custom-fields',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_device_health_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        health: Annotated[Optional[StrictStr], Field(description="Health status filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDeviceHealthReportDefaultResponse:
        """Device health report

        Returns list of device health summary records

        :param df: Device filter
        :type df: str
        :param health: Health status filter
        :type health: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_health_report_serialize(
            df=df,
            health=health,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_device_health_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        health: Annotated[Optional[StrictStr], Field(description="Health status filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDeviceHealthReportDefaultResponse]:
        """Device health report

        Returns list of device health summary records

        :param df: Device filter
        :type df: str
        :param health: Health status filter
        :type health: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_health_report_serialize(
            df=df,
            health=health,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_device_health_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        health: Annotated[Optional[StrictStr], Field(description="Health status filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Device health report

        Returns list of device health summary records

        :param df: Device filter
        :type df: str
        :param health: Health status filter
        :type health: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_health_report_serialize(
            df=df,
            health=health,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_device_health_report_serialize(
        self,
        df,
        health,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if health is not None:
            
            _query_params.append(('health', health))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/device-health',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_device_usage(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        include_deleted_devices: Annotated[Optional[StrictBool], Field(description="Whether or not include deleted devices")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDeviceUsage200Response:
        """Device backup usage

        Returns the backup usage by device

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param include_deleted_devices: Whether or not include deleted devices
        :type include_deleted_devices: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_usage_serialize(
            cursor=cursor,
            page_size=page_size,
            include_deleted_devices=include_deleted_devices,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceUsage200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_device_usage_with_http_info(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        include_deleted_devices: Annotated[Optional[StrictBool], Field(description="Whether or not include deleted devices")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDeviceUsage200Response]:
        """Device backup usage

        Returns the backup usage by device

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param include_deleted_devices: Whether or not include deleted devices
        :type include_deleted_devices: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_usage_serialize(
            cursor=cursor,
            page_size=page_size,
            include_deleted_devices=include_deleted_devices,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceUsage200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_device_usage_without_preload_content(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        include_deleted_devices: Annotated[Optional[StrictBool], Field(description="Whether or not include deleted devices")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Device backup usage

        Returns the backup usage by device

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param include_deleted_devices: Whether or not include deleted devices
        :type include_deleted_devices: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_device_usage_serialize(
            cursor=cursor,
            page_size=page_size,
            include_deleted_devices=include_deleted_devices,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetDeviceUsage200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_device_usage_serialize(
        self,
        cursor,
        page_size,
        include_deleted_devices,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if include_deleted_devices is not None:
            
            _query_params.append(('includeDeletedDevices', include_deleted_devices))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/backup/usage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_disk_drives(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetDiskDrivesDefaultResponse:
        """Disk drives report

        Returns list of physical disks

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_disk_drives_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_disk_drives_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetDiskDrivesDefaultResponse]:
        """Disk drives report

        Returns list of physical disks

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_disk_drives_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_disk_drives_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Disk drives report

        Returns list of physical disks

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_disk_drives_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_disk_drives_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/disks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_installed_os_patches(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter (FAILED, INSTALLED)")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include patches installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include patches installed after specified date")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInstalledOSPatchesDefaultResponse:
        """OS Patch installation report

        Returns patch installation history records (successful and failed)

        :param df: Device filter
        :type df: str
        :param status: Patch Status filter (FAILED, INSTALLED)
        :type status: str
        :param installed_before: Include patches installed before specified date
        :type installed_before: str
        :param installed_after: Include patches installed after specified date
        :type installed_after: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_installed_os_patches_serialize(
            df=df,
            status=status,
            installed_before=installed_before,
            installed_after=installed_after,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_installed_os_patches_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter (FAILED, INSTALLED)")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include patches installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include patches installed after specified date")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInstalledOSPatchesDefaultResponse]:
        """OS Patch installation report

        Returns patch installation history records (successful and failed)

        :param df: Device filter
        :type df: str
        :param status: Patch Status filter (FAILED, INSTALLED)
        :type status: str
        :param installed_before: Include patches installed before specified date
        :type installed_before: str
        :param installed_after: Include patches installed after specified date
        :type installed_after: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_installed_os_patches_serialize(
            df=df,
            status=status,
            installed_before=installed_before,
            installed_after=installed_after,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_installed_os_patches_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter (FAILED, INSTALLED)")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include patches installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include patches installed after specified date")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """OS Patch installation report

        Returns patch installation history records (successful and failed)

        :param df: Device filter
        :type df: str
        :param status: Patch Status filter (FAILED, INSTALLED)
        :type status: str
        :param installed_before: Include patches installed before specified date
        :type installed_before: str
        :param installed_after: Include patches installed after specified date
        :type installed_after: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_installed_os_patches_serialize(
            df=df,
            status=status,
            installed_before=installed_before,
            installed_after=installed_after,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_installed_os_patches_serialize(
        self,
        df,
        status,
        installed_before,
        installed_after,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if installed_before is not None:
            
            _query_params.append(('installedBefore', installed_before))
            
        if installed_after is not None:
            
            _query_params.append(('installedAfter', installed_after))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/os-patch-installs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_installed_software_patches(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        impact: Annotated[Optional[StrictStr], Field(description="Patch Impact filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        product_identifier: Annotated[Optional[StrictStr], Field(description="Product Identifier")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include patches installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include patches installed after specified date")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInstalledSoftwarePatchesDefaultResponse:
        """Software Patch history report

        Returns 3rd party software patch installation history records (successful and failed)

        :param df: Device filter
        :type df: str
        :param type: Patch Type filter
        :type type: str
        :param impact: Patch Impact filter
        :type impact: str
        :param status: Patch Status filter
        :type status: str
        :param product_identifier: Product Identifier
        :type product_identifier: str
        :param installed_before: Include patches installed before specified date
        :type installed_before: str
        :param installed_after: Include patches installed after specified date
        :type installed_after: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_installed_software_patches_serialize(
            df=df,
            type=type,
            impact=impact,
            status=status,
            product_identifier=product_identifier,
            installed_before=installed_before,
            installed_after=installed_after,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_installed_software_patches_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        impact: Annotated[Optional[StrictStr], Field(description="Patch Impact filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        product_identifier: Annotated[Optional[StrictStr], Field(description="Product Identifier")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include patches installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include patches installed after specified date")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInstalledSoftwarePatchesDefaultResponse]:
        """Software Patch history report

        Returns 3rd party software patch installation history records (successful and failed)

        :param df: Device filter
        :type df: str
        :param type: Patch Type filter
        :type type: str
        :param impact: Patch Impact filter
        :type impact: str
        :param status: Patch Status filter
        :type status: str
        :param product_identifier: Product Identifier
        :type product_identifier: str
        :param installed_before: Include patches installed before specified date
        :type installed_before: str
        :param installed_after: Include patches installed after specified date
        :type installed_after: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_installed_software_patches_serialize(
            df=df,
            type=type,
            impact=impact,
            status=status,
            product_identifier=product_identifier,
            installed_before=installed_before,
            installed_after=installed_after,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_installed_software_patches_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        impact: Annotated[Optional[StrictStr], Field(description="Patch Impact filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        product_identifier: Annotated[Optional[StrictStr], Field(description="Product Identifier")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include patches installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include patches installed after specified date")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Software Patch history report

        Returns 3rd party software patch installation history records (successful and failed)

        :param df: Device filter
        :type df: str
        :param type: Patch Type filter
        :type type: str
        :param impact: Patch Impact filter
        :type impact: str
        :param status: Patch Status filter
        :type status: str
        :param product_identifier: Product Identifier
        :type product_identifier: str
        :param installed_before: Include patches installed before specified date
        :type installed_before: str
        :param installed_after: Include patches installed after specified date
        :type installed_after: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_installed_software_patches_serialize(
            df=df,
            type=type,
            impact=impact,
            status=status,
            product_identifier=product_identifier,
            installed_before=installed_before,
            installed_after=installed_after,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_installed_software_patches_serialize(
        self,
        df,
        type,
        impact,
        status,
        product_identifier,
        installed_before,
        installed_after,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if impact is not None:
            
            _query_params.append(('impact', impact))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if product_identifier is not None:
            
            _query_params.append(('productIdentifier', product_identifier))
            
        if installed_before is not None:
            
            _query_params.append(('installedBefore', installed_before))
            
        if installed_after is not None:
            
            _query_params.append(('installedAfter', installed_after))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/software-patch-installs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_last_logged_on_users_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetLastLoggedOnUsersReportDefaultResponse:
        """Last logged-on user report

        Returns usernames and logon times 

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_last_logged_on_users_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_last_logged_on_users_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetLastLoggedOnUsersReportDefaultResponse]:
        """Last logged-on user report

        Returns usernames and logon times 

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_last_logged_on_users_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_last_logged_on_users_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Last logged-on user report

        Returns usernames and logon times 

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_last_logged_on_users_report_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_last_logged_on_users_report_serialize(
        self,
        df,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/logged-on-users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_interfaces(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetNetworkInterfacesDefaultResponse:
        """List Network Interfaces

        Returns list of Network Interfaces for each device

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size:
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_interfaces_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_interfaces_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetNetworkInterfacesDefaultResponse]:
        """List Network Interfaces

        Returns list of Network Interfaces for each device

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size:
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_interfaces_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_interfaces_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Network Interfaces

        Returns list of Network Interfaces for each device

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size:
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_interfaces_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_interfaces_serialize(
        self,
        df,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/network-interfaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_operating_systems(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOperatingSystemsDefaultResponse:
        """Operating systems report

        Returns operating systems' for devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_operating_systems_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_operating_systems_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOperatingSystemsDefaultResponse]:
        """Operating systems report

        Returns operating systems' for devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_operating_systems_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_operating_systems_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Operating systems report

        Returns operating systems' for devices

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_operating_systems_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_operating_systems_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/operating-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_pending_failed_rejected_os_patches(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        severity: Annotated[Optional[StrictStr], Field(description="Patch Severity filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInstalledOSPatchesDefaultResponse:
        """Pending, Failed and Rejected OS patches report

        Returns list of OS patches for which there were no installation attempts

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param status: Patch Status filter
        :type status: str
        :param type: Patch Type filter
        :type type: str
        :param severity: Patch Severity filter
        :type severity: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_failed_rejected_os_patches_serialize(
            df=df,
            ts=ts,
            status=status,
            type=type,
            severity=severity,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_pending_failed_rejected_os_patches_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        severity: Annotated[Optional[StrictStr], Field(description="Patch Severity filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInstalledOSPatchesDefaultResponse]:
        """Pending, Failed and Rejected OS patches report

        Returns list of OS patches for which there were no installation attempts

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param status: Patch Status filter
        :type status: str
        :param type: Patch Type filter
        :type type: str
        :param severity: Patch Severity filter
        :type severity: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_failed_rejected_os_patches_serialize(
            df=df,
            ts=ts,
            status=status,
            type=type,
            severity=severity,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_pending_failed_rejected_os_patches_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        severity: Annotated[Optional[StrictStr], Field(description="Patch Severity filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Pending, Failed and Rejected OS patches report

        Returns list of OS patches for which there were no installation attempts

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param status: Patch Status filter
        :type status: str
        :param type: Patch Type filter
        :type type: str
        :param severity: Patch Severity filter
        :type severity: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_failed_rejected_os_patches_serialize(
            df=df,
            ts=ts,
            status=status,
            type=type,
            severity=severity,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_pending_failed_rejected_os_patches_serialize(
        self,
        df,
        ts,
        status,
        type,
        severity,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if severity is not None:
            
            _query_params.append(('severity', severity))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/os-patches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_pending_failed_rejected_software_patches(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        product_identifier: Annotated[Optional[StrictStr], Field(description="Product Identifier")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        impact: Annotated[Optional[StrictStr], Field(description="Patch Impact filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetInstalledSoftwarePatchesDefaultResponse:
        """Pending, Failed and Rejected Software patches report

        Returns list of 3rd party Software patches for which there were no installation attempts

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param status: Patch Status filter
        :type status: str
        :param product_identifier: Product Identifier
        :type product_identifier: str
        :param type: Patch Type filter
        :type type: str
        :param impact: Patch Impact filter
        :type impact: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_failed_rejected_software_patches_serialize(
            df=df,
            ts=ts,
            status=status,
            product_identifier=product_identifier,
            type=type,
            impact=impact,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_pending_failed_rejected_software_patches_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        product_identifier: Annotated[Optional[StrictStr], Field(description="Product Identifier")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        impact: Annotated[Optional[StrictStr], Field(description="Patch Impact filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetInstalledSoftwarePatchesDefaultResponse]:
        """Pending, Failed and Rejected Software patches report

        Returns list of 3rd party Software patches for which there were no installation attempts

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param status: Patch Status filter
        :type status: str
        :param product_identifier: Product Identifier
        :type product_identifier: str
        :param type: Patch Type filter
        :type type: str
        :param impact: Patch Impact filter
        :type impact: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_failed_rejected_software_patches_serialize(
            df=df,
            ts=ts,
            status=status,
            product_identifier=product_identifier,
            type=type,
            impact=impact,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_pending_failed_rejected_software_patches_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        status: Annotated[Optional[StrictStr], Field(description="Patch Status filter")] = None,
        product_identifier: Annotated[Optional[StrictStr], Field(description="Product Identifier")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Patch Type filter")] = None,
        impact: Annotated[Optional[StrictStr], Field(description="Patch Impact filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Pending, Failed and Rejected Software patches report

        Returns list of 3rd party Software patches for which there were no installation attempts

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param status: Patch Status filter
        :type status: str
        :param product_identifier: Product Identifier
        :type product_identifier: str
        :param type: Patch Type filter
        :type type: str
        :param impact: Patch Impact filter
        :type impact: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pending_failed_rejected_software_patches_serialize(
            df=df,
            ts=ts,
            status=status,
            product_identifier=product_identifier,
            type=type,
            impact=impact,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_pending_failed_rejected_software_patches_serialize(
        self,
        df,
        ts,
        status,
        product_identifier,
        type,
        impact,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if product_identifier is not None:
            
            _query_params.append(('productIdentifier', product_identifier))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if impact is not None:
            
            _query_params.append(('impact', impact))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/software-patches',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_policy_overrides1(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPolicyOverrides1DefaultResponse:
        """Get summary of device policy overrides

        Returns list of overridden policy sections for each device

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_overrides1_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_policy_overrides1_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPolicyOverrides1DefaultResponse]:
        """Get summary of device policy overrides

        Returns list of overridden policy sections for each device

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_overrides1_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_policy_overrides1_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get summary of device policy overrides

        Returns list of overridden policy sections for each device

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_policy_overrides1_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_policy_overrides1_serialize(
        self,
        df,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/policy-overrides',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_processors(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetProcessorsDefaultResponse:
        """Processor report

        Returns list of processors

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_processors_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_processors_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetProcessorsDefaultResponse]:
        """Processor report

        Returns list of processors

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_processors_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_processors_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Processor report

        Returns list of processors

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_processors_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_processors_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/processors',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_raid_controller_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetRAIDControllerReportDefaultResponse:
        """RAID controller report

        Returns list of RAID controllers

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raid_controller_report_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_raid_controller_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetRAIDControllerReportDefaultResponse]:
        """RAID controller report

        Returns list of RAID controllers

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raid_controller_report_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_raid_controller_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """RAID controller report

        Returns list of RAID controllers

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raid_controller_report_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_raid_controller_report_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/raid-controllers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_raid_drive_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetRAIDDriveReportDefaultResponse:
        """RAID drive report

        Returns list of drives connected to RAID controllers

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raid_drive_report_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_raid_drive_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetRAIDDriveReportDefaultResponse]:
        """RAID drive report

        Returns list of drives connected to RAID controllers

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raid_drive_report_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_raid_drive_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """RAID drive report

        Returns list of drives connected to RAID controllers

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_raid_drive_report_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_raid_drive_report_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/raid-drives',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_scoped_custom_fields_detailed_report(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        scopes: Annotated[Optional[StrictStr], Field(description="Comma-separated list of scopes")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetScopedCustomFieldsDetailedReportDefaultResponse:
        """Scoped custom fields detailed report

        Returns report for Custom Fields defined at different scopes (device, location, organization) with additional information about each field

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param scopes: Comma-separated list of scopes
        :type scopes: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scoped_custom_fields_detailed_report_serialize(
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            scopes=scopes,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_scoped_custom_fields_detailed_report_with_http_info(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        scopes: Annotated[Optional[StrictStr], Field(description="Comma-separated list of scopes")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetScopedCustomFieldsDetailedReportDefaultResponse]:
        """Scoped custom fields detailed report

        Returns report for Custom Fields defined at different scopes (device, location, organization) with additional information about each field

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param scopes: Comma-separated list of scopes
        :type scopes: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scoped_custom_fields_detailed_report_serialize(
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            scopes=scopes,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_scoped_custom_fields_detailed_report_without_preload_content(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        scopes: Annotated[Optional[StrictStr], Field(description="Comma-separated list of scopes")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Scoped custom fields detailed report

        Returns report for Custom Fields defined at different scopes (device, location, organization) with additional information about each field

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param scopes: Comma-separated list of scopes
        :type scopes: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scoped_custom_fields_detailed_report_serialize(
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            scopes=scopes,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_scoped_custom_fields_detailed_report_serialize(
        self,
        cursor,
        page_size,
        updated_after,
        fields,
        scopes,
        show_secure_values,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if updated_after is not None:
            
            _query_params.append(('updatedAfter', updated_after))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if scopes is not None:
            
            _query_params.append(('scopes', scopes))
            
        if show_secure_values is not None:
            
            _query_params.append(('showSecureValues', show_secure_values))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/scoped-custom-fields-detailed',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_scoped_custom_fields_report(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        scopes: Annotated[Optional[StrictStr], Field(description="Comma-separated list of scopes")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetScopedCustomFieldsReportDefaultResponse:
        """Scoped custom fields report

        Returns report for Custom Fields defined at different scopes (device, location, organization)

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param scopes: Comma-separated list of scopes
        :type scopes: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scoped_custom_fields_report_serialize(
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            scopes=scopes,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_scoped_custom_fields_report_with_http_info(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        scopes: Annotated[Optional[StrictStr], Field(description="Comma-separated list of scopes")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetScopedCustomFieldsReportDefaultResponse]:
        """Scoped custom fields report

        Returns report for Custom Fields defined at different scopes (device, location, organization)

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param scopes: Comma-separated list of scopes
        :type scopes: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scoped_custom_fields_report_serialize(
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            scopes=scopes,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_scoped_custom_fields_report_without_preload_content(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        updated_after: Annotated[Optional[StrictStr], Field(description="Custom fields updated after specified date")] = None,
        fields: Annotated[Optional[StrictStr], Field(description="Comma-separated list of fields")] = None,
        scopes: Annotated[Optional[StrictStr], Field(description="Comma-separated list of scopes")] = None,
        show_secure_values: Annotated[Optional[StrictBool], Field(description="Flag to indicate if secure values should be returned as plain text without encryption")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Scoped custom fields report

        Returns report for Custom Fields defined at different scopes (device, location, organization)

        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param updated_after: Custom fields updated after specified date
        :type updated_after: str
        :param fields: Comma-separated list of fields
        :type fields: str
        :param scopes: Comma-separated list of scopes
        :type scopes: str
        :param show_secure_values: Flag to indicate if secure values should be returned as plain text without encryption
        :type show_secure_values: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scoped_custom_fields_report_serialize(
            cursor=cursor,
            page_size=page_size,
            updated_after=updated_after,
            fields=fields,
            scopes=scopes,
            show_secure_values=show_secure_values,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_scoped_custom_fields_report_serialize(
        self,
        cursor,
        page_size,
        updated_after,
        fields,
        scopes,
        show_secure_values,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if updated_after is not None:
            
            _query_params.append(('updatedAfter', updated_after))
            
        if fields is not None:
            
            _query_params.append(('fields', fields))
            
        if scopes is not None:
            
            _query_params.append(('scopes', scopes))
            
        if show_secure_values is not None:
            
            _query_params.append(('showSecureValues', show_secure_values))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/scoped-custom-fields',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_software(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include software installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include software installed after specified date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetSoftwareDefaultResponse:
        """Software inventory

        Returns list software installed on devices

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param installed_before: Include software installed before specified date
        :type installed_before: str
        :param installed_after: Include software installed after specified date
        :type installed_after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_software_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            installed_before=installed_before,
            installed_after=installed_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_software_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include software installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include software installed after specified date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetSoftwareDefaultResponse]:
        """Software inventory

        Returns list software installed on devices

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param installed_before: Include software installed before specified date
        :type installed_before: str
        :param installed_after: Include software installed after specified date
        :type installed_after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_software_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            installed_before=installed_before,
            installed_after=installed_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_software_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        installed_before: Annotated[Optional[StrictStr], Field(description="Include software installed before specified date")] = None,
        installed_after: Annotated[Optional[StrictStr], Field(description="Include software installed after specified date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Software inventory

        Returns list software installed on devices

        :param df: Device filter
        :type df: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param installed_before: Include software installed before specified date
        :type installed_before: str
        :param installed_after: Include software installed after specified date
        :type installed_after: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_software_serialize(
            df=df,
            cursor=cursor,
            page_size=page_size,
            installed_before=installed_before,
            installed_after=installed_after,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_software_serialize(
        self,
        df,
        cursor,
        page_size,
        installed_before,
        installed_after,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if installed_before is not None:
            
            _query_params.append(('installedBefore', installed_before))
            
        if installed_after is not None:
            
            _query_params.append(('installedAfter', installed_after))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/software',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_volumes(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        include: Annotated[Optional[StrictStr], Field(description="Additional information to include (bl - BitLocker status)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetVolumesDefaultResponse:
        """Disk volumes report

        Returns list of disk volumes

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param include: Additional information to include (bl - BitLocker status)
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_volumes_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_volumes_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        include: Annotated[Optional[StrictStr], Field(description="Additional information to include (bl - BitLocker status)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetVolumesDefaultResponse]:
        """Disk volumes report

        Returns list of disk volumes

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param include: Additional information to include (bl - BitLocker status)
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_volumes_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_volumes_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        ts: Annotated[Optional[StrictStr], Field(description="Monitoring timestamp filter")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[StrictInt], Field(description="Limit number of records per page")] = None,
        include: Annotated[Optional[StrictStr], Field(description="Additional information to include (bl - BitLocker status)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Disk volumes report

        Returns list of disk volumes

        :param df: Device filter
        :type df: str
        :param ts: Monitoring timestamp filter
        :type ts: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param include: Additional information to include (bl - BitLocker status)
        :type include: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_volumes_serialize(
            df=df,
            ts=ts,
            cursor=cursor,
            page_size=page_size,
            include=include,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_volumes_serialize(
        self,
        df,
        ts,
        cursor,
        page_size,
        include,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if ts is not None:
            
            _query_params.append(('ts', ts))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        if include is not None:
            
            _query_params.append(('include', include))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/volumes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_windows_services_report(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Service name")] = None,
        state: Annotated[Optional[StrictStr], Field(description="Service state")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetWindowsServicesReportDefaultResponse:
        """Windows services report

        Returns list of Windows Services and their statuses

        :param df: Device filter
        :type df: str
        :param name: Service name
        :type name: str
        :param state: Service state
        :type state: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_windows_services_report_serialize(
            df=df,
            name=name,
            state=state,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_windows_services_report_with_http_info(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Service name")] = None,
        state: Annotated[Optional[StrictStr], Field(description="Service state")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetWindowsServicesReportDefaultResponse]:
        """Windows services report

        Returns list of Windows Services and their statuses

        :param df: Device filter
        :type df: str
        :param name: Service name
        :type name: str
        :param state: Service state
        :type state: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_windows_services_report_serialize(
            df=df,
            name=name,
            state=state,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_windows_services_report_without_preload_content(
        self,
        df: Annotated[Optional[StrictStr], Field(description="Device filter")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Service name")] = None,
        state: Annotated[Optional[StrictStr], Field(description="Service state")] = None,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor name")] = None,
        page_size: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=10)]], Field(description="Limit number of records per page")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Windows services report

        Returns list of Windows Services and their statuses

        :param df: Device filter
        :type df: str
        :param name: Service name
        :type name: str
        :param state: Service state
        :type state: str
        :param cursor: Cursor name
        :type cursor: str
        :param page_size: Limit number of records per page
        :type page_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_windows_services_report_serialize(
            df=df,
            name=name,
            state=state,
            cursor=cursor,
            page_size=page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_windows_services_report_serialize(
        self,
        df,
        name,
        state,
        cursor,
        page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if df is not None:
            
            _query_params.append(('df', df))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if page_size is not None:
            
            _query_params.append(('pageSize', page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'sessionKey', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v2/queries/windows-services',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


